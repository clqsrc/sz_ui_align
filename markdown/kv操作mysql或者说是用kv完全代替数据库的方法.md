
# <center>使用 kv 操作完全代替数据库 sql</center>


实际上大多数数据库操作都可以分解成多个 key/value 的请求形式。

目前已知要扩展的只需要是指定两个 key 的情况，而两个 key 的情况实际上可以转化成对于一个 value 的类型又是一个 kv 的 list 的情况。

这样一思考实际上和 json 只有 kv 和 array 类型就足够了是一样的。

以以下的一张用户数据表为例进行讲解:

```

    +-------+------------+-------------+-----------+
    |   ID  |  ID_GUID   |  user_name  | file_name |
    |       |            |             |           |
    +-------+------------+-------------+-----------+
    |   1   |abc-1234-cde|     ccc     |   file1   |
    |       |     f      |             |           |
    +-------+------------+-------------+-----------+

```


这里假设 ID 字段是自增量的不确定主键，而 ID_GUID 是用户给每一条数据指定的主键（使用随机的 guid 生成器即可）。使用过数据库的用户都知道实际上这个自增量的 ID 用做关键字实际上是不保险的，在数据库压缩或者重新生成时会发生改变，而且也不利于数据的导入导出。

但假如只有一个用户自定义的 ID_GUID 的话在某些数据库中就会导致数据存储后读取的顺序不确定。所以数据库自增量的 ID 我们建议还是保留。

在没有数据库的文件实现中实际上相当于文件的顺序号（以生成时间排序时）。


## SQL 直接操作的问题

从业过程中见过复杂的 SQL 语句和储存过程导致用户的 mssql 服务器隔一两天就要重启一次的情况。引发的原因是开发者在开发时只注重结果，而对 SQL 语言可能引起的性能问题漠不关心（更多时候是并不了解）。

这也不能怪罪这些开发者，即便是更老道的开发者也保证不了他编写的 sql 不会造成数据库卡顿，这样的问题一旦发生是很难查找的。更不用说隐藏着什么时候触发的情况。



